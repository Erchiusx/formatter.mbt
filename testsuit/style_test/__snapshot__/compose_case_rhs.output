// generated file, do not edit!
fn collapsible_apply() -> Unit {
  match e {
    Pattern => f(arg1, arg2)
    Pattern_______________________________________________________ => 
      f(arg1, arg2, arg3)
    Pattern_______________________________________________________ => {
      f(
        arg1_____________________,
        arg2_____________________,
        arg3_____________________,
      )
    }
    Pattern_______________________________________________________ => {
      f_______________________________(
        arg1_____________________,
        arg2_____________________,
        arg3_____________________,
      )
    }
  }
}

fn collapsible_array() -> Unit {
  match e {
    Pattern => [arg1, arg2]
    Pattern_______________________________________________________ => [
      arg1,
      arg2,
      arg3,
    ]
    Pattern_______________________________________________________ => [
      arg1_____________________,
      arg2_____________________,
      arg3_____________________,
    ]
  }
}

fn collapsible_record() -> Unit {
  match e {
    Pattern => { field1, field2 }
    Pattern_______________________________________________________ => {
      arg1,
      arg2,
      arg3,
    }
    Pattern_______________________________________________________ => {
      arg1_____________________,
      arg2_____________________,
      arg3_____________________,
    }
  }
}

fn collapsible_constraint() -> Unit {
  match e {
    Pattern => (expr : Anno)
    Pattern_______________________________________________________ => (
      expr________
      : Anno________
    )
    Pattern_______________________________________________________ => (
      expr_______________________________________________
      : Anno_________________________________________
    )
  }
}

fn collapsible_if() -> Unit {
  match e {
    Pattern => if a { b } else { c }
    Pattern_______________________________________________________ => 
      if a { b } else { c }
    Pattern_______________________________________________________ => {
      if a {
        b________________________________
      } else {
        c_____________________________
      }
    }
    Pattern_______________________________________________________ => {
      if a_______________________________ {
        b__________________________
      } else {
        c________________________
      }
    }
  }
}

fn collapsible_ident() -> Unit {
  match e {
    Pattern => id
    Pattern_______________________________________________________ => {
      id__________________
    }
    Pattern_______________________________________________________ => {
      id________________________________________________________________________________
    }
  }
}

fn collapsible_dot_apply() -> Unit {
  match e {
    Pattern => self.method(arg1, arg2)
    Pattern_______________________________________________________ => 
      self.method(arg1, arg2)
    Pattern_______________________________________________________ => {
      self
        .method(
          arg1__________________________,
          arg2____________________,
          arg3_____________________,
        )
    }
    Pattern_______________________________________________________ => {
      [
        arg1_________________________,
        arg2_____________________,
        arg3________________,
      ]
      .method(
          arg1__________________________,
          arg2____________________,
          arg3_____________________,
        )
    }
  }
}

fn collapsible_dot_apply_chain() -> Unit {
  match e {
    Pattern => self.method(arg1, arg2).method2(arg1, arg2)
    Pattern_______________________________________________________ => 
      self.method(arg1, arg2).method(arg1, arg2)
    Pattern_______________________________________________________ => {
      self
        .method(
          arg1__________________________,
          arg2____________________,
          arg3_____________________,
        )
        .method(arg1____________________________, arg2____________________)
    }
    Pattern_______________________________________________________ => {
      [
        arg1_________________________,
        arg2_____________________,
        arg3________________,
      ]
      .method(
          arg1__________________________,
          arg2____________________,
          arg3_____________________,
        )
        .method(arg1____________________________, arg2____________________)
    }
  }
}

fn not_collapsible_assign() -> Unit {
  match e {
    Pattern => a = b
    Pattern_______________________________________________________ => {
      a________ = b_________
    }
    Pattern_______________________________________________________ => {
      a________ = b______________________________________________________________________
    }
    Pattern_______________________________________________________ => {
      a__________________________________ = b____________________________________________
    }
  }
}

