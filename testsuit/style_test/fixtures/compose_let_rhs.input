fn collapsible_apply() -> Unit {
  // fits after `=>`
  let a = f(arg1, arg2)
  // fits in next line
  let Pattern_______________________________________________________ = f(arg1, arg2, arg3)
  // the body of collapsible expression does not fit in the next line
  let Pattern_______________________________________________________ = 
    f(arg1_____________________, arg2_____________________, arg3_____________________)
  // the head of collapsible expression does not fit in the next line
  let Pattern_______________________________________________________ = 
    f_______________________________(arg1_____________________, arg2_____________________, arg3_____________________)
}

fn collapsible_array() -> Unit {
  // fits after `=>`
  let Pattern = [arg1, arg2]
  // fits in next line
  let Pattern_______________________________________________________ = [arg1, arg2, arg3]
  // the body of collapsible expression does not fit in the next line
  let Pattern_______________________________________________________ = 
    [arg1_____________________, arg2_____________________, arg3_____________________]
}

fn collapsible_record() -> Unit {
  // fits after `=>`
  let Pattern = { field1, field2 }
  // fits in next line
  let Pattern_______________________________________________________ = { arg1, arg2, arg3 }
  // the body of collapsible expression does not fit in the next line
  let Pattern_______________________________________________________ =
    { arg1_____________________, arg2_____________________, arg3_____________________ }
}

fn collapsible_constraint() -> Unit {
  // fits after `=>`
  let Pattern = (expr : Anno)
  // fits in next line
  let Pattern_______________________________________________________ = (expr________ : Anno________)
  // the body of collapsible expression does not fit in the next line
  let Pattern_______________________________________________________ =
    (expr_______________________________________________ : Anno_________________________________________-)
}

fn collapsible_if() -> Unit {
  // fits after `=>`
  let Pattern = if a { b } else { c }
  // fits in next line
  let Pattern__________________________________________________________ = if a { b } else { c }
  // the body of collapsible expression does not fit in the next line
  let Pattern___________________________________________________ = if a { 
    b________________________________ 
  } else { 
    c_____________________________ 
  }
  // the head of collapsible expression does not fit in the next line
  let Pattern___________________________________________________ = 
    if a_______________________________ { b__________________________ } else { c________________________ }
}

fn collapsible_dot_apply() -> Unit {
  // fits after `=>`
  let a = self.method(arg1, arg2)
  // fits in next line
  let Pattern_______________________________________________________ = self.method(arg1, arg2, arg3)
  // the body of collapsible expression does not fit in the next line
  let Pattern_________________________ = 
    self.method(arg1_____________________, arg2_____________________, arg3_____________________)
  // the head of collapsible expression does not fit in the next line
  let Pattern_______________________________________________________ = 
    [arg1_________________________, arg2__________________________, arg3____________________].method(arg1_____________________, arg2_____________________, arg3_____________________)
}